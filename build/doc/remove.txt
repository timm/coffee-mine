Node partR(Node h, int k) 
  { int t = (h.l == null) ? 0 : h.l.N; 
    if (t > k) 
      { partR(h.l, k); h = rotR(h); } 
    if (t < k) 
      { partR(h.r, k-t-1); h = rotL(h); } 
    return h; 
  } 

private Node removeR(Node h, KEY v) 
  { if (h == null) return null; 
    KEY w = h.item.key(); 
    if (less(v, w)) removeR(h.l, v); 
    if (less(w, v)) removeR(h.r, v); 
    if (equals(v, w)) h = joinLR(h.l, h.r); 
    return h; 
  } 

void remove(KEY v) 
  { removeR(head, v); 
  } 

private Node joinLR(Node a, Node b) 
  { int N = a.N + b.N; 
    if (a == null) return b; 
    if (b == null) return a; 
    if (Math.random()*N < 1.0*a.N) 
         { a.r = joinLR(a.r, b); return a; } 
    else { b.l = joinLR(a, b.l); return b; } 
  } 


Tree-PLRU, is an efficient algorithm to find an item that most likely has not been accessed very recently, given a set of items and a sequence of access events to the items. This technique is used in the CPU cache of the Intel 486 and in many processors in the Power Architecture (formerly PowerPC) family, such as Freescale's PowerPC G4 used by Apple Computer. The algorithm works as follows: consider a binary search tree for the items in question. Each node of the tree has a one-bit flag denoting "go left to find a pseudo-LRU element" or "go right to find a pseudo-LRU element". To find a pseudo-LRU element, traverse the tree according to the values of the flags. To update the tree with an access to an item N, traverse the tree to find N and, during the traversal, set the node flags to denote the direction that is opposite to the direction taken.
