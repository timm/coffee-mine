#!/usr/bin/env coffee
# Copyright (c) 2011,2012 Tim Menzies, MIT License
# 
#  #####   #####    ####    #####
#  #    #  #    #  #          #
#  #    #  #####    ####      #
#  #####   #    #       #     #
#  #   #   #    #  #    #     #
#  #    #  #####    ####      #
# 
# Version ....... : rbst-131
# Built ......... : Thu Jan 12 10:00:19 EST 2012
# License ....... : see below.
# Installation .. : see below.
# Report bugs ... : https://github.com/timm/coffee-mine/issues
# For doco ...... : read http://coffee.unbox.org around Thu Jan 12 10:00:19 EST 2012
 
#--| lib/globals.coffee |-------------------------------------------------------------
 
pow  = Math.pow
e    = Math.E
pi   = Math.PI
sqrt = Math.sqrt
ln   = Math.log
show = console.log

inf  = 1e+32
ninf = -1 * inf

d2 = (n) -> Math.round(n*100)/100

d3 = (n) -> Math.round(n*1000)/1000

d4 = (n) -> Math.round(n*10000)/10000

nummat = (number, decimals, dec=".", sep=",") ->
  # from http://goo.gl/2vcMH
  number = (number + '').replace(/[^0-9+\-Ee.]/g, '')
  n      = if isFinite(+number) then +number else 0
  prec   = if isFinite(+decimals) then Math.abs(decimals) else 0
  s      = ''
  toFixedFix =  (n, prec) ->
    k = Math.pow(10, prec)
    '' + Math.round(n * k) / k
  s = if prec then toFixedFix(n, prec) else '' + Math.round(n)
  s = s.split('.')
  if (s[0].length > 3)
     s[0] = s[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, sep)
  if (s[1]  || '').length < prec
      s[1] = s[1] || ''
      s[1] += new Array(prec - s[1].length + 1).join('0')
   s.join(dec)
 
#--| lib/rand.coffee |-------------------------------------------------------------
 
class Rand
  # Knuth and Lewis' improvements to Park and Miller's LCPRNG
  # if created without a seed, uses current time as seed
  constructor: (@seed) ->
    @multiplier = 1664525
    @modulo     = 4294967296 # 2**32-1;
    @offset     = 1013904223
    unless @seed? && 0 <= seed < @modulo
      @seed = (new Date().valueOf() * new Date().getMilliseconds()) % @modulo

  seed: (seed)      -> @seed = seed
  randn:            -> @seed = (@multiplier*@seed + @offset) % @modulo
  randf:            -> @randn() / @modulo
  rand:  (n)        -> Math.floor(@randf() * n)
  rand2: (min, max) -> min + @rand(max-min)

R = new Rand

shuffle = (l,r = R) ->
  n = l.length
  for i in [n-1..1]
    j = r.rand2(0,i)
    [ l[i],  l[j] ] = [ l[j], l[i] ]
  l

normal = (m,s,r = R) ->
  boxMuller = () ->
    w=1
    while w >= 1
      x1 = 2.0 * r.randf() - 1
      x2 = 2.0 * r.randf() - 1
      w  = x1*x1 + x2*x2
    w = sqrt((-2.0 * ln(w))/w)
    x1 * w
  m + boxMuller() * s

any = (l,r=R) ->
  l[r.rand2(0,l.length)]
 
#--| lib/rbst.coffee |-------------------------------------------------------------
 
###
 NAME
====

Rbst

Synopsis
========

Add 1,000 randomly
generated key value pairs to a RandomBinaryTree:

    one = -> x R.rand2(1,10000), R.rand2(1,10)
    b = null
    for n in [1..1000]
      thing = one()
      if not b
        b = new RandomBinaryTree thing.x, thing.y
      else
        b.add thing
     b.show()

The last line does a pretty print of the generated tree.

Description
===========

A [random binary search
tree](http://en.wikipedia.org/wiki/Randomized_binary_search_tree)
(RBST) is a way to build an (approximately) balanced binary search
tree.

RBSTs are very simple to code and incrementally maintain their balance.
That is, when using them, you never need to pause to rebalance the tree.

RBSTs are based on binary search trees (BST):

+ A BST  contains nodes with a `key,value` and
`left` and `right` pointers to sub-trees. In such trees, all the
`left` keys are less than or equal to the local `key` and all the
`right` jeys are greater than the local `key`.
+ Ideally, a BST is _balanced_; i.e. it has the same number of nodes
in the `left` and `right` sub-trees. In such a tree, _N_ items can be
found in _O(log N)_ time.

The RBST stores at each node a small integer, the number of
its descendants (counting itself as one). When a key _x_ is to be inserted
into a tree that already has _n_ nodes:

+ The insertion algorithm chooses
with probability _1/(n + 1)_ to place _x_ as the new root of the tree.
+ Otherwise, it calls the insertion procedure recursively to insert _x_
within the `left` or `right` subtree (depending on whether its key is less
than or greater than the root).

The numbers of descendants `n` are used by the algorithm to calculate the
necessary probabilities for the random choices at each step.

Files
=====

+ This file : [rbst.coffee](https://raw.github.com/timm/coffee-mine/master/build/lib/rbst.coffee).
+ Uses the random number generator  :
[rand.coffee](https://raw.github.com/timm/coffee-mine/master/build/lib/rand.coffee).
+ And the standard global definitions of
  [globals.coffee](https://raw.github.com/timm/coffee-mine/master/build/lib/globals.coffee).
+ All code in
  [one file](https://github.com/timm/coffee-mine/blob/master/build/var/rbst-103).

Annotated Source Code
=====================

Creation
--------

A new tree contains one node and has nil for the `left` and `right` pointers.

Tree Manipulation
------------------

Rotating left and right is way to move a sub-node up a tree,
while preserving the BST invariant that the left/right keys
in the new sub-trees are in the right order.

![left, right rotate](http://upload.wikimedia.org/wikipedia/commons/2/23/Tree_rotation.png)
###
class RandomBinaryTree
  constructor: (@key,@value) ->
    @n = null
    @local = 1
    @left = @right = null

# `RotateR` and `rotateL` is used
# by the `rootInsert` function. This
# function pushes a new node up a tree to the root
# of that tree.
  rotateL: (h) ->
    x = h.right
    h.right = x.left
    x.left = h
    h.reset(); x.reset();
    x
  rotateR: (h) ->
    x   = h.left
    h.left = x.right
    x.right = h
    h.reset(); x.reset();
    x
  reset:() ->
    @n = null
  update:() ->
    @n  = @local
    @n += @left.size()  if @left
    @n += @right.size() if @right
  size:() ->
    @update() if @n is null
    @n

# Inserting an Item
# -----------------
#
# `insert` adds a new node to a sub-tree.
# For a sub-tree of size `n`, at probability
#   _1/(n+1)_, the new node is inserted to the root.
# Otherwise, it is inserted somewhere into the leaves.
#
# Note that `rootInsert` and `insert`
# support `lt`- a customisable
# comparison operator for two keys.
  insert: (h,key,val,lt) ->
    if h is null
      return new RandomBinaryTree key,val
    if R.randf() < (1/(h.size()))
      return @rootInsert h,     key,val,lt
    if lt key,h.key
      h.left = @insert h.left,key,val,lt
    else if key is h.key
      h.local += 1
    else
      h.right  = @insert h.right,key,val,lt
    h.reset()
    h

  rootInsert: (h,key,val,lt) ->
    if h is null
      return new RandomBinaryTree key,val
    if lt key,h.key
      h.left = @rootInsert h.left,  key,val,lt
      h      = @rotateR h
    else if key is h.key
      h.local += 1
    else
      h.right = @rootInsert h.right,key,val,lt
      h       = @rotateL h
    h.reset()
    h
# `Adds` and `add` are convenience functions
# for adding pairs of key values.
#
# `Adds` inserts multiple pairs.
  adds: (many, lt = ((x,y) -> x < y)) ->
    out = @
    for one in many
      out = @insert out, one.x,one.y, lt
    out

# `Add` inserts one pair
  add: (one, lt = ((x,y) -> x < y)) ->
    @insert @ , one.x,one.y, lt

# Printing the tree
# -----------------
#
# Simple recursive function to print
# nodes, with an indentation equal
# to the depth of the node in the tree
  show: (indent="",prefix="=",add="|   ") ->
    s = "#{indent}#{prefix}#{@key} has #{@local} so #{@size()} :  #{@value}"
    show s
    @left.show  indent+add,"<= ",add if @left
    @right.show indent+add,">  ",add if @right
###

Helper Functions
----------------

`x` is a convenient way to generate a value pair.

###
x = (x,y) -> new Pair x,y

class Pair
  constructor: (@x,@y) ->

###
Bugs
====

None known (yet) but if you find any, please [report them here](https://github.com/timm/coffee-mine/issues?sort=comments&direction=desc&state=open).

AUTHOR
======

[Tim Menzies](https://github.com/timm)

COPYRIGHT
=========

Share and enjoy.
Makedown by [Tim Menzies](https://github.com/timm) is licensed under a
[Creative Commons Attribution-ShareAlike 3.0 Unported License](http://creativecommons.org/licenses/by-sa/3.0/)
### 
#--| rbst.coffee |-------------------------------------------------------------
 
one = -> x R.rand2(1,8), R.rand2(1,10)
b = null
R = new Rand 1
all = (one() for n in [1..20])
for thing in all
  if not b
    b = new RandomBinaryTree thing.x, thing.y
  else
    b = b.add thing
b.show()
 
# CREDITS
# =======
# 
# Tim Menzies tim@menzies.us
# 
# INSTALL
# =======
# 
# 0)  Essential first step: make yourself a cup of coffee.
# 1)  Install coffee on your local machine.
# 
# 2)  Download this file and call it, say,  'lib/globals.coffee'.
#     2a) Optional (UNIX systems only)
# 
#        chmod +x lib/globals.coffee  # <=== On UNIX systems
# 
# 3)  Look for 'data/' in this file. Usually, its the last few
#     lines of code (above). If you see any reference to such 
#     a data file, then...
#     3a) Download those data files from
#         http://now.unbox.org/all/trunk/doc/coffee-mine/data
#     3b) Edit this file so it points to those data files.
# 
# 4)  See if this file runs:
# 
#         ./lib/globals.coffee         # <=== UNIX systems
#         coffee lib/globals.coffee    # <=== for other systems
# 
# To check if it is running correctly, see http://coffee.unbox.com 
# (look for blogs entries around lib/rbst.coffee).
# 
# COPYRIGHT
# ---------
# 
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
# 
